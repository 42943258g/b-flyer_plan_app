<!doctype html>
<html lang="ja">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>折込配布プラン管理</title>

  <link href="https://unpkg.com/tabulator-tables@6.2.5/dist/css/tabulator.min.css" rel="stylesheet">

  <style>
    body{font-family:system-ui, -apple-system, "Noto Sans JP", sans-serif; margin:20px;}
    .row{display:flex; gap:10px; flex-wrap:wrap; align-items:center; margin-bottom:10px;}
    button{padding:10px 14px; border-radius:10px; border:1px solid #bbb; background:#fff; cursor:pointer;}
    input, select{padding:8px; border-radius:10px; border:1px solid #ccc;}
    .hint{color:#666; font-size:13px;}
    #grid{border:1px solid #ddd; border-radius:10px; overflow:hidden;}
    .log{white-space:pre-wrap; background:#0b1020; color:#d6e0ff; padding:12px; border-radius:10px; height:180px; overflow:auto; font-family:ui-monospace, Menlo, Consolas, monospace;}
    code{background:#f4f4f4; padding:2px 6px; border-radius:6px;}

    /* ===== Loading Overlay (Spinner) ===== */
    #loadingOverlay{
      position: fixed;
      inset: 0;
      background: rgba(255,255,255,.75);
      display: none;              /* ←普段は非表示 */
      align-items: center;
      justify-content: center;
      z-index: 9999;
      backdrop-filter: blur(2px);
    }
    #loadingOverlay .panel{
      background:#fff;
      border:1px solid #ddd;
      border-radius:14px;
      padding:18px 22px;
      display:flex;
      align-items:center;
      gap:12px;
      box-shadow: 0 10px 30px rgba(0,0,0,.12);
      min-width: 220px;
    }
    #loadingOverlay .spinner{
      width:22px;
      height:22px;
      border:3px solid #cfcfcf;
      border-top-color:#333;
      border-radius:50%;
      animation: spin 0.9s linear infinite;
    }
    #loadingOverlay .msg{
      font-size:14px;
      color:#222;
      white-space: nowrap;
    }
    @keyframes spin { to { transform: rotate(360deg); } }
  </style>
</head>
<body>
  <h1>折込配布プラン管理</h1>

  <div class="row">
    <label>対象</label>
    <select id="target">
      <option value="schedule">schedule</option>
      <option value="shop_master">shop_master</option>
      <option value="syoken">syoken</option>
    </select>

    <button id="reloadBtn">読み込み</button>

    <input id="newColName" placeholder="列追加（例: 店番）" />
    <button id="addColBtn">列追加</button>

    <button id="saveBtn">保存（全置換）</button>
    <button id="excelBtn">Excelダウンロード</button>
  </div>

  <div class="hint">
    - シートは常に <b>最低999行</b> 表示されます（空行は保存時にスキップ）<br/>
    - 列は <b>ドラッグで並べ替え</b>（列順は保存）<br/>
    - <b>ヘッダクリックでソート</b>（Shift+クリックで複数）→ ソート状態も保存<br/>
    - 列削除：<b>列ヘッダ右クリック → 列を削除</b>
  </div>

  <div id="grid" style="margin-top:10px;"></div>

  <h3 style="margin-top:14px;">ログ</h3>
  <div id="log" class="log"></div>

  <!-- ===== Loading Overlay (scriptより前に置く) ===== -->
  <div id="loadingOverlay" aria-hidden="true">
    <div class="panel" role="status" aria-live="polite">
      <div class="spinner"></div>
      <div class="msg">処理中…</div>
    </div>
  </div>

  <script src="https://unpkg.com/tabulator-tables@6.2.5/dist/js/tabulator.min.js"></script>
  <script>
    const MIN_ROWS = 999;

    const logEl = document.getElementById("log");
    function log(s){ logEl.textContent += s + "\n"; logEl.scrollTop = logEl.scrollHeight; }

    // ===== Spinner制御 =====
    const overlayEl = document.getElementById("loadingOverlay");
    const overlayMsgEl = overlayEl.querySelector(".msg");
    function setLoading(on, msg="処理中…"){
      overlayMsgEl.textContent = msg;
      overlayEl.style.display = on ? "flex" : "none";
      overlayEl.setAttribute("aria-hidden", on ? "false" : "true");

      // 操作ミス防止で主要UIを一時無効化
      const ids = ["reloadBtn","addColBtn","saveBtn","excelBtn","target","newColName"];
      for(const id of ids){
        const el = document.getElementById(id);
        if(el) el.disabled = !!on;
      }
    }

    const DEBUG_KEYS = false;

    function aeInfo(){
      const ae = document.activeElement;
      if(!ae) return "active=null";
      const id = ae.id ? `#${ae.id}` : "";
      const cls = ae.className ? `.${String(ae.className).split(" ").join(".")}` : "";
      return `active=${ae.tagName}${id}${cls}`;
    }

    function cellInfo(cell){
      try{
        if(!cell) return "cell=null";
        const f = cell.getColumn().getField();
        const p = cell.getRow().getPosition?.();
        return `cell=${f}@rowPos=${p}`;
      }catch{
        return "cell=? (err)";
      }
    }

    function rangeInfo(){
      try{
        const ranges = table?.getRanges?.() || [];
        if(!ranges.length) return "ranges=0";
        const r = ranges[ranges.length - 1];
        const s = r.getStructuredCells?.();
        const c = s?.[0]?.[0];
        return `ranges=${ranges.length} start=${cellInfo(c)}`;
      }catch{
        return "ranges=? (err)";
      }
    }

    const targetEl = document.getElementById("target");
    let table = null;
    let lastCell = null;

    // ===== Excel風：キー入力で編集開始（Tabulator生成より先に登録するのが重要） =====
    function openEditorLikeExcel(cell, firstChar=null){
      if(!cell) return;

      // Tabulator APIで編集開始
      try { cell.edit(true); } catch {}

      // inputが出なかったら、dblclick相当で確実に開く
      setTimeout(() => {
        const el = cell.getElement?.();
        if(!el) return;

        let input = el.querySelector("input,textarea");
        if(!input){
          el.dispatchEvent(new MouseEvent("dblclick", { bubbles:true, cancelable:true, view:window }));
          input = el.querySelector("input,textarea");
        }
        if(input){
          input.focus();
          if(firstChar){
            input.value = firstChar;
            input.dispatchEvent(new Event("input", { bubbles:true }));
            try { input.setSelectionRange(input.value.length, input.value.length); } catch {}
          }
        }
      }, 0);
    }

    // Tabulatorより先に window capture で掴む
    window.addEventListener("keydown", (e) => {
      if (!table) return;

      if (DEBUG_KEYS) {
        const t = e.target;
        const tName = t?.tagName ? t.tagName : String(t);
        log(`[KEY] key=${e.key} code=${e.code} ctrl=${e.ctrlKey} meta=${e.metaKey} alt=${e.altKey} | target=${tName} | ${aeInfo()} | last=${cellInfo(lastCell)} | ${rangeInfo()}`);
      }

      const t = e.target;
      if (t && t.closest && t.closest("input,textarea,select,[contenteditable='true']")) return;
      if (e.ctrlKey || e.metaKey || e.altKey) return;

      const isEditKey = (e.key === "Enter" || e.key === "F2");
      const isChar   = (e.key && e.key.length === 1);
      const isIme    = (e.key === "Process");
      if (!isEditKey && !isChar && !isIme) return;

      let startCell = lastCell;
      const ranges = table.getRanges?.() || [];
      if (ranges.length) {
        const range = ranges[ranges.length - 1];
        const structured = range.getStructuredCells?.();
        startCell = structured?.[0]?.[0] || startCell;
      }
      if (!startCell) return;

      e.preventDefault();
      e.stopPropagation();

      openEditorLikeExcel(startCell, isChar ? e.key : null);
    }, true);

    let currentColumns = [];

    const kColOrder = (t) => `colOrder:${t}`;
    const kSort = (t) => `sorters:${t}`;

    function loadJSON(key){
      try{ const s = localStorage.getItem(key); return s ? JSON.parse(s) : null; }catch{ return null; }
    }
    function saveJSON(key, val){
      try{ localStorage.setItem(key, JSON.stringify(val)); }catch{}
    }

    function loadColumnOrder(target){
      const v = loadJSON(kColOrder(target));
      return Array.isArray(v) ? v.filter(x => x !== "shop_code") : null;
    }
    function saveColumnOrder(target, cols){
      saveJSON(kColOrder(target), cols.filter(x => x !== "shop_code"));
    }

    function loadSorters(target){
      const v = loadJSON(kSort(target));
      return Array.isArray(v) ? v.filter(s => s.column !== "shop_code") : null;
    }
    function saveSorters(target, sorters){
      saveJSON(kSort(target), (sorters || []).filter(s => s.column !== "shop_code"));
    }

    function normalizeColumns(serverCols, rows, target){
      const set = new Set((serverCols || []).filter(c => c !== "shop_code"));
      for(const r of (rows || [])){
        if(r && typeof r === "object"){
          Object.keys(r).forEach(k => { if(k !== "shop_code") set.add(k); });
        }
      }

      const saved = loadColumnOrder(target);
      const all = Array.from(set);

      if(saved && saved.length){
        const ordered = [];
        for(const c of saved) if(set.has(c)) ordered.push(c);
        for(const c of all) if(!ordered.includes(c)) ordered.push(c);
        return ordered.length ? ordered : (all.length ? all : ["col1"]);
      }
      return all.length ? all : ["col1"];
    }

    function makeEmptyRow(){
      const empty = {};
      for(const c of currentColumns) empty[c] = "";
      return empty;
    }

    function ensureMinRows(rows, n){
      while(rows.length < n){
        rows.push(makeEmptyRow());
      }
    }

    function buildColumns(cols, target){
      const headerMenu = function(){
        return [{
          label: "列を削除",
          action: function(e, column){
            const field = column.getField();
            if(!confirm(`列「${field}」を削除しますか？（データからも消えます）`)) return;

            const data = table.getData();
            for(const r of data) delete r[field];
            table.replaceData(data);

            currentColumns = currentColumns.filter(c => c !== field);
            table.setColumns(buildColumns(currentColumns, target));

            saveColumnOrder(target, currentColumns);

            const s = loadSorters(target) || [];
            const filtered = s.filter(x => x.column !== field);
            saveSorters(target, filtered);
            table.clearSort();
            if(filtered.length) table.setSort(filtered);

            log(`列削除: ${field}`);
          }
        }];
      };

      return cols.map(c => ({
        title: c,
        field: c,
        editor: "input",
        headerSort: true,
        headerMenu,
      }));
    }

    function clipboardMatrixParser(clipboard){
      clipboard = (clipboard ?? "")
        .replace(/\r\n/g, "\n")
        .replace(/\r/g, "\n");

      let lines = clipboard.split("\n");
      while(lines.length && lines[lines.length - 1].trim() === ""){
        lines.pop();
      }
      return lines.map(line => line.split("\t"));
    }

    function clipboardMatrixPasteAction(pasteMatrix){
      if(!table) return [];

      const ranges = table.getRanges?.() || [];
      if(!ranges.length) return [];

      const range = ranges[ranges.length - 1];
      const structured = range.getStructuredCells?.();
      const startCell = structured?.[0]?.[0];
      if(!startCell) return [];

      const visibleCols = table.getColumns()
        .filter(c => c && c.isVisible && c.isVisible() && c.getField && c.getField());

      const startField = startCell.getColumn().getField();
      const startColIndex = visibleCols.findIndex(c => c.getField() === startField);
      if(startColIndex < 0) return [];

      const baseRowIndex = (startCell.getRow().getPosition() || 1) - 1;
      const allRows = table.getRows();

      const touched = [];
      for(let r = 0; r < pasteMatrix.length; r++){
        const rowComp = allRows[baseRowIndex + r];
        if(!rowComp) break;

        const rowVals = pasteMatrix[r] || [];
        for(let c = 0; c < rowVals.length; c++){
          const colComp = visibleCols[startColIndex + c];
          if(!colComp) break;

          const cell = rowComp.getCell(colComp);
          if(cell){
            cell.setValue(rowVals[c], true);
          }
        }
        touched.push(rowComp);
      }

      return touched;
    }

    async function loadTable(){
      setLoading(true, "読み込み中…");
      try{
        logEl.textContent = "";
        const target = targetEl.value;
        log(`読み込み: ${target} ...`);

        const res = await fetch(`/api/table/${target}`);
        const data = await res.json();
        if(!res.ok){ log("ERROR: " + (data.detail || res.statusText)); return; }

        let rows = [];
        let serverCols = [];

        if (Array.isArray(data)) {
          rows = data;
        } else {
          rows = data.rows || [];
          serverCols = data.columns || [];
        }

        currentColumns = normalizeColumns(serverCols, rows, target);

        ensureMinRows(rows, MIN_ROWS);

        const sorters = loadSorters(target) || [];

        if(!table){
          table = new Tabulator("#grid", {
            data: rows,
            layout: "fitDataStretch",
            height: "560px",
            reactiveData: true,

            movableColumns: true,
            columns: buildColumns(currentColumns, target),

            rowHeader: { formatter: "rownum", headerSort: false, width: 50, hozAlign: "center" },

            editTriggerEvent: "dblclick",
            selectable: false,

            selectableRange: 1,
            selectableRangeColumns: true,
            selectableRangeRows: true,
            selectableRangeClearCells: true,

            clipboard: true,
            clipboardCopyStyled: false,
            clipboardPasteParser: clipboardMatrixParser,
            clipboardPasteAction: clipboardMatrixPasteAction,
          });

          const rememberCell = (cell) => {
            const ae = document.activeElement;
            if (ae && ae.blur && /^(INPUT|TEXTAREA|SELECT|BUTTON)$/.test(ae.tagName)) {
              ae.blur();
            }
            lastCell = cell;
            if(DEBUG_KEYS) log(`[CLICK] ${cellInfo(lastCell)} | ${aeInfo()} | ${rangeInfo()}`);
          };

          table.on("cellMouseDown", (e, cell) => rememberCell(cell));
          table.on("cellTap", (e, cell) => rememberCell(cell));
          table.on("cellClick", (e, cell) => rememberCell(cell));

          table.on("clipboardPasted", (clipboard, rowData, rows) => {
            if (!rowData || !rowData.length || !rows || !rows.length) return;

            const lastRowData = rowData[rowData.length - 1];
            const allEmpty = Object.values(lastRowData || {}).every(v => (v ?? "") === "");
            if (!allEmpty) return;

            const lastRow = rows[rows.length - 1];
            const cells = lastRow.getCells();
            for (const cell of cells) {
              cell.setValue(cell.getOldValue());
            }
          });

          table.on("columnMoved", () => {
            const t = targetEl.value;
            const fields = table.getColumns().map(col => col.getField()).filter(Boolean);
            currentColumns = fields.filter(x => x !== "shop_code");
            saveColumnOrder(t, currentColumns);
            log("列順を保存しました");
          });

          table.on("dataSorted", (sortersNow) => {
            const t = targetEl.value;
            saveSorters(t, sortersNow || []);
            log("ソート状態を保存しました");
          });

          const holder = table.getElement().querySelector(".tabulator-tableholder");
          if (holder) holder.tabIndex = 0;

          if (!window.__excelLikeKeyHandlerAdded) {
            window.__excelLikeKeyHandlerAdded = true;
          }

        } else {
          table.setColumns(buildColumns(currentColumns, target));
          table.replaceData(rows);
        }

        saveColumnOrder(target, currentColumns);

        table.clearSort();
        if(sorters.length){
          const valid = sorters.filter(s => currentColumns.includes(s.column));
          if(valid.length) table.setSort(valid);
        }

        log(`OK: rows=${rows.length} cols=${currentColumns.length}`);
      } finally {
        setLoading(false);
      }
    }

    function ensureColumn(name){
      name = (name || "").trim();
      if(!name) return;
      if(currentColumns.includes(name)) return;

      currentColumns.push(name);
      table.setColumns(buildColumns(currentColumns, targetEl.value));
      saveColumnOrder(targetEl.value, currentColumns);

      const data = table.getData();
      for(const r of data){
        if(!(name in r)) r[name] = "";
      }
      table.replaceData(data);

      log(`列追加: ${name}`);
    }

    async function saveReplace(){
      if(!table) return;

      setLoading(true, "保存中…");
      try{
        const target = targetEl.value;
        const rows = table.getData();

        log(`保存開始: ${target} rows=${rows.length}`);

        const res = await fetch(`/api/save/${target}`, {
          method: "POST",
          headers: {"Content-Type":"application/json"},
          body: JSON.stringify({ rows, columns: currentColumns })
        });
        const data = await res.json();
        if(!res.ok){ log("ERROR: " + (data.detail || res.statusText)); return; }

        log(`OK: saved=${data.saved}`);

        table.clearSort();
        try { localStorage.removeItem(`sorters:${target}`); } catch {}

        await loadTable();
      } finally {
        setLoading(false);
      }
    }

    document.getElementById("reloadBtn").onclick = loadTable;
    targetEl.onchange = loadTable;

    document.getElementById("addColBtn").onclick = () => {
      if(!table) return;
      const name = document.getElementById("newColName").value;
      ensureColumn(name);
      document.getElementById("newColName").value = "";
    };

    document.getElementById("saveBtn").onclick = saveReplace;

    // ★テンプレ(list_format.xlsx)をそのままダウンロード
    document.getElementById("excelBtn").onclick = () => {
      log("Excelダウンロード（テンプレ）…");
      setLoading(true, "Excel作成中…");
      window.location.href = "/api/export-xlsx";
      log("DL開始");
      // ダウンロード完了の検知が難しいので、適当な時間で消す（必要なら調整）
      setTimeout(() => setLoading(false), 2500);
    };

    loadTable();
  </script>
</body>
</html>
